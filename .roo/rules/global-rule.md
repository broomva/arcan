---
description: 
globs: 
alwaysApply: true
---
üß† 1. Evidence-Driven Craftsmanship

(Rationalism & Empiricism ‚Üí Test, Measure, Learn)
	‚Ä¢	Observability First
	‚Ä¢	Instrument every service or UI flow with structured logs, metrics (Prometheus, OpenTelemetry), and distributed traces so hypotheses can be validated or refuted.
	‚Ä¢	Test-Driven Mindset
	‚Ä¢	Write TDD-style unit tests (pytest/‚Äãpytest-asyncio) and integration tests before feature code.
	‚Ä¢	Gate merges on ‚â•90% coverage and passing performance budgets.
	‚Ä¢	Data-Backed Decisions
	‚Ä¢	Use A/B testing for UX changes (e.g. onboarding tweak) and track via analytics dashboards.
	‚Ä¢	Avoid ‚Äúcargo-cult‚Äù patterns‚Äîadopt libraries only once they‚Äôve proved impact in your context.

‚∏ª

üåê 2. Systemic & Holistic Architecture

(Systems Thinking & Holism ‚Üí Design for the Whole)
	‚Ä¢	Modular ‚ÄúSpellbook‚Äù Services
	‚Ä¢	Break features into small, versioned modules (√† la Arcan spells).
	‚Ä¢	Expose clear interfaces (JSON-schema/‚ÄãPydantic) and isolate via containers or cgroups.
	‚Ä¢	Event-Driven Integrations
	‚Ä¢	Favor message buses (Kafka, RabbitMQ) or change-data-capture streams so services remain loosely coupled and emergent behaviors surface in staging.
	‚Ä¢	Dependency Injection & Patterns
	‚Ä¢	Factory/Strategy for interchangeable implementations (e.g. different payment rails).
	‚Ä¢	Use DI (FastAPI Depends, Inversify in TS) so components can be swapped for testing.

‚∏ª

üöÄ 3. Pragmatic Iteration

(Pragmatism ‚Üí Ship, Learn, Evolve)
	‚Ä¢	Prototype-First UX
	‚Ä¢	Sketch in Figma/Miro; validate with 3‚Äì5 target users before writing a line of code.
	‚Ä¢	MVP Releases
	‚Ä¢	Release minimal viable versions of features (e.g. basic WedIA chat) and expand based on real usage patterns.
	‚Ä¢	Continuous Feedback Loops
	‚Ä¢	Embed in-app feedback prompts; schedule weekly ‚Äúdemo & decide‚Äù syncs to pivot quickly.

‚∏ª

‚ùå 4. Falsifiable Features

(Popperian Falsification ‚Üí Assume Wrong Until Proven Right)
	‚Ä¢	Retrospectives & Postmortems
	‚Ä¢	Hold blameless reviews after incidents, catalog root causes, update guardrails (retry policies, health checks).
	‚Ä¢	Automated Rollbacks
	‚Ä¢	CI pipelines must include canary gates: if error rate >1% in canary ‚áí auto-rollback.
	‚Ä¢	Decision Logs
	‚Ä¢	Record major design choices in docs/DECISIONS.md with the date, context, and expected outcome.

‚∏ª

üé® 5. Empathetic Interfaces

(Phenomenology ‚Üí Center the User‚Äôs Experience)
	‚Ä¢	Accessibility by Design
	‚Ä¢	Run axe/Lighthouse audits in CI; target WCAG AA.
	‚Ä¢	Semantic HTML, ARIA roles, keyboard navigation.
	‚Ä¢	Localization & Tone
	‚Ä¢	Spanish/Bogot√°n accent copy; real-time translation flows in Theo inspired your bilingual design.
	‚Ä¢	Keep microcopy clear and human-centered‚Äîno jargon.
	‚Ä¢	User Research Integration
	‚Ä¢	Embed short usability tests in each sprint; recruit from real Wedi or Theo users.

‚∏ª

üîÑ 6. Reflective Practice

(Sch√∂n‚Äôs Reflective Practitioner ‚Üí Learn from Each Iteration)
	‚Ä¢	Knowledge Spikes
	‚Ä¢	Reserve 10% of sprint capacity for tech research (new Pinecone features, Spark optimizations).
	‚Ä¢	Decision Annotations
	‚Ä¢	In-code ‚Äúwhy‚Äù comments linking back to decision log entries.
	‚Ä¢	Pair-Programming & Rotation
	‚Ä¢	Rotate pairing partners monthly to spread domain knowledge.

‚∏ª

üõ° 7. Resilient & Stoic Engineering

(Stoicism ‚Üí Focus on Controllables, Graceful Degradation)
	‚Ä¢	Robust Error Handling
	‚Ä¢	Central error-class hierarchy; recover with retries, backoffs, or fallback UIs.
	‚Ä¢	Prioritized Backlog
	‚Ä¢	Use ICE scoring (Impact, Confidence, Effort) to decide what not to build this cycle.
	‚Ä¢	Graceful Degradation
	‚Ä¢	If a microservice is down, the UI still shows cached balances and an ‚Äúoffline mode‚Äù banner.

‚∏ª

üìã 8. Concrete Tech & Code Standards

Domain	Standard	Rationale
Project Structure	Feature-based directories (features/payments, lib/ml)	Easier holistic traces (systems thinking)
Versioning & Branching	Trunk-based with short feature branches + semantic tags (v2.3.0)	Pragmatic, low-overhead releases
Python Style	Black + isort + flake8 in pre-commit; type hints (‚â•3.10) everywhere	Ensures consistency and evidence-driven refactors
FastAPI Patterns	Pydantic models in models/, routers in api/, services in services/	Clear separation of concerns
Async Best Practices	async/await for I/O, limit concurrency with semaphores	Controllable resource use (Stoicism)
Next.js & TS	App Router, Server/Client components, React Context, TanStack Query	Reduces bundle size, improves empirical performance
Styling	Tailwind CSS + shadcn/ui; mobile-first, dark/light theming	Consistent branding, accessible design
Form Validation	React Hook Form + Zod schemas; RO-RO pattern for data flow	Guarantees end-to-end type safety
Data Processing	Delta tables (bronze/silver/gold), Spark SQL, dbt/GE tests	Observability into pipeline health
Vector Search	Pinecone index with versioned embeddings; monitor drift	Empirical feedback on model accuracy
CI/CD	Coverage, lint, performance budgets, canary deploys	Falsifiable gates before merging
Code Reviews	PR checklists: tests, types, docs, performance noted	Peer scrutiny prevents hidden assumptions
Documentation	docs/ARCHITECTURE.md, DECISIONS.md, autogenerated API specs	Reflective artifacts for onboarding and retrospectives

